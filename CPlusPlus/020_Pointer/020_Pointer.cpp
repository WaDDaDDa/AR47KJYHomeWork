#include <iostream>


void ValueChangePtr(int* Ptr)
{
	*Ptr = 0;
}

void ValueChangeValue(int Ptr)
{
	Ptr = 0;
}


int main()
{

	// int는 4바이트 정수의 자료형인데

	// __int64는 8바이트 정수 자료형이다.
	__int64 Value = 10;
	
	// 포인터란 C++의 자료형의 한 형태이며
	// 자료형 뒤에 *을 붙여서 선언한다.
	int* ptr;
	bool* ptrb;

	// 포인터는 램에서의 위치를 의미하게 된다.
	int Value1 = 10; // 라고 한다면.
	Value1; // 특정 주소값에 만들어진 비트값 10을 의미하게된다.

	// Value1가 표현하는 값이 2가지 있다.
	// 내부의 자신의 진짜 비트값 10
	// 그 이름을 통해서 램에 존재하게 되는 자신의 위치인 100번지(양의정수 번지의 주소)
	// 0인 번지의 주소는 Nullptr로 정해져있다.
	int* ValuePtr = &Value1; // ValuePtr 에 Value1의 주소값을 넣겠다 라는 뜻.

	// Unsigned가 생긴이유 Ram이나 이런 주소값을 표현할때 음수인 번지는 없다.

	// 형변환의 형태만 알고가자.
	// 주소값은 기본적으로 16진수의 형태로 표현하기 때문에 
	// 형변환을 통해 정수로 읽을수 있도록 한것이 아래의 문구이다.
	
	__int64 Address = 0;
	Address = (__int64)ValuePtr;
	// 왜 int가아닌 __int64로 했냐면.
	// 4바이트인 int형으로는 포인터의 값을 전부 정수로 표현할수 없기 때문에
	// 8바이트인 __int64형으로 받아서 읽도록 해준 것 이다.

	// 포인터는 기본적으로 8바이트의 크기를 가진다.  (64비트 빌드 에서)
	//  주소의 번지는 1바이트당 취급 하는것이랑은 다른 개념이다.
	// 32비트 빌드에서는 포인터가 4바이트의 크기를 가져서 괜찮았지만 . 이제는 아니다.
	// 그 주소(램에서의 위치의 정수값)를 전문적으로 다룬다.

	{
		// 16진수 표현법
		int Value2 = 0b00000000000000000000000000000000; // 2진수 표현
		int Value16 = 0xffffffff; //16진수 표현
	}

	{
		// 아직은 자세히 몰라도 되는 지식.

		// 버츄얼 어드레스.(가상주소)
		// 램에서의 실제위치가 아닌 임의대로의 주소를 운영체제가 부여해 주게 된다.


	}

	*Ptr = 20;
	ValueChange(&Value);  // 다른함수에 있는 변수에는 접근할수없다.  (지역변수)

	ValueChangeValue(Value);
	
	int* ptr = Value;




}

